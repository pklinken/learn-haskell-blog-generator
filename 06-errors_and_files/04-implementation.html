<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Let&#x27;s code already! - Learn Haskell by building a blog generator</title>
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="../06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/04-implementation.html" class="active"><strong aria-hidden="true">6.4.</strong> Let's code already!</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="../08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="../09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="../10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="../12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lets-code-already"><a class="header" href="#lets-code-already">Let's code already!</a></h1>
<p>This was a long info dump. Let's practice what we've learned. We want to:</p>
<ul>
<li>Create the output directory</li>
<li>Grab all file names in a directory</li>
<li>Filter them according to their extension</li>
<li>Process .txt files</li>
<li>Copy other files without modification</li>
<li>Parse each text file, build an index of the result,
convert the files to HTML, and write everything to the target directory</li>
</ul>
<blockquote>
<p>Note: I did not write this code immediately in the final form it was presented.
It was an iterative process of writing code, refactoring, splitting functions, changing
type signatures, and more. When solving a coding problem, start small and simple,
do the thing that works, and refactor it when it makes sense and makes the code clearer
and more modular. In Haskell, we pride ourselves in our ability to refactor code and improve
it over time, and that principle holds when writing new software as well!</p>
</blockquote>
<h2 id="new-module"><a class="header" href="#new-module">New module</a></h2>
<p>Let's create a new module, <code>HsBlog.Directory</code>, which will be responsible for handling
directories and multiple files. From this module, we will export the <code>convertDirectory</code>
and <code>buildIndex</code> functions we've defined before:</p>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where
</code></pre>
<p>In this module, we are going to use the
<a href="https://hackage.haskell.org/package/directory-1.3.7.0/docs/System-Directory.html">directory</a>
and <a href="https://hackage.haskell.org/package/filepath-1.4.2.1/docs/System-FilePath.html">filepath</a>
libraries to manipulate directories, files, and file paths.
We'll use the new abstractions we've learned, <code>Traversable</code> and <code>Monad</code>, and the concepts
and types we've learned about: <code>Either</code>, <code>IO</code>, and exceptions.</p>
<p>For all of that, we need quite a few imports:</p>
<pre><code class="language-hs">import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )
</code></pre>
<p>If you are unsure what a specific function we're using does, look it up at
<a href="https://hoogle.haskell.org/">Hoogle</a>,
read the type signature and the documentation, and play around with it in <code>ghci</code>.</p>
<h2 id="converting-a-directory"><a class="header" href="#converting-a-directory">Converting a directory</a></h2>
<p>We can start by describing the high-level function <code>convertDirectory</code>, which
encapsulates many smaller functions, each responsible for doing a specific thing.
<code>convertDirectory</code> is quite imperative looking, and looks like a different way to
describe the steps of completing our task:</p>
<pre><code class="language-hs">-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;
</code></pre>
<p>Here we trust that each <code>IO</code> function handles errors responsibly,
and terminates the project when necessary.</p>
<p>Let's examine the steps in order.</p>
<h3 id="getdirfilesandcontent"><a class="header" href="#getdirfilesandcontent"><code>getDirFilesAndContent</code></a></h3>
<pre><code class="language-hs">-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents

</code></pre>
<p><code>getDirFilesAndContent</code> is responsible for providing the relevant files for processing --
both the ones we need to convert to markup (and their textual content) and other files we
might want to copy as-is (such as images and style-sheets):</p>
<pre><code class="language-hs">-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }
</code></pre>
<p>This function does 4 important things:</p>
<ol>
<li>Lists all the files in the directory</li>
<li>Splits the files into 2 groups according to their file extension</li>
<li>Reads the contents of the .txt files and reports when files fail to be read</li>
<li>Returns the results. We've defined a data type to make the result content more obvious</li>
</ol>
<p>Part (3) is a little bit more involved than the rest; let's explore it.</p>
<h4 id="applyioonlist"><a class="header" href="#applyioonlist"><code>applyIoOnList</code></a></h4>
<hr />
<p><code>applyIoOnList</code> has the following type signature:</p>
<pre><code class="language-hs">applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
</code></pre>
<p>It tries to apply an <code>IO</code> function on a list of values and document successes and failures.</p>
<p>Try to implement it! If you need a hint for which functions to use, see the import list
we wrote earlier.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action inputs = do
  for inputs $ \input -&gt; do
    maybeResult &lt;-
      catch
        (Right &lt;$&gt; action input)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (input, maybeResult)
</code></pre>
</details>
<hr />
<p><code>applyIoOnList</code> is a higher-order function that applies a particular <code>IO</code> function
(in our case, <code>readFile</code>) on a list of things (in our case, <code>FilePath</code>s).
For each thing, it returns the thing itself along with the result of
applying the <code>IO</code> function as an <code>Either</code>, where the <code>Left</code> side is a <code>String</code>
representation of an error if one occurred.</p>
<p>Notice how much the type of this function tells us about what it might do.
Because the types are polymorphic, there is nothing else to do with
the <code>a</code>s other than apply them to the function, and nowhere to generate <code>b</code>
from other than the result of the function.</p>
<blockquote>
<p>Note: when I first wrote this function, it was specialized to work only on <code>readFile</code>,
take specifically <code>[FilePath]</code> and return <code>IO [(FilePath, Either String String)]</code>.
But after running into other use cases where I could use it (<code>writeFiles</code> and <code>copyFiles</code>)
I refactored out the <code>action</code>, the input type, and the return type.</p>
</blockquote>
<p>This function uses exceptions to catch any error that might be thrown and encodes
both the failure and success cases in the type system using <code>Either</code>, delaying
the handling of exceptions to the function caller while making sure it won't
be forgotten!</p>
<p>Next, let's look at the function that handles the errors by reporting and then filtering out
all the cases that failed.</p>
<h4 id="filterandreportfailures"><a class="header" href="#filterandreportfailures"><code>filterAndReportFailures</code></a></h4>
<hr />
<p><code>filterAndReportFailures</code> has the following type signature:</p>
<pre><code class="language-hs">filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
</code></pre>
<p>It filters out unsuccessful operations on files and reports errors to the stderr.</p>
<p>Try to implement it!</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \(file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]
</code></pre>
<p>This code may seem a bit surprising - how come we can use <code>foldMap</code> here? Reminder,
the type of <code>foldMap</code> is:</p>
<pre><code class="language-hs">foldMap :: (Foldable t, Monoid m) =&gt; (a -&gt; m) -&gt; t a -&gt; m
</code></pre>
<p>If we specialize this function for our use case, substituting the general type
with the types we are using, we learn that <code>IO [(a, b)]</code> is a monoid.
And indeed - <code>[a]</code> is a monoid for any <code>a</code> with <code>[]</code> (the empty list) as <code>mempty</code>
and <code>++</code> as <code>&lt;&gt;</code>, but also <code>IO a</code> is a monoid for any <code>a</code> that is itself
a monoid with <code>pure mempty</code> as <code>mempty</code> and <code>liftA2 (&lt;&gt;)</code> as <code>&lt;&gt;</code>!</p>
<p>Using these instances, we can <code>map</code> over the content, handle errors, and return
an empty list to filter out a failed case, or a singleton list to keep the result.
And the <code>fold</code> in <code>foldMap</code> will concatenate the resulting list where we return
all of the successful cases!</p>
<p>If you've written this in a different way that does the same thing, that's fine too!
It's just nice to see how sometimes abstractions can be used to write concise code.</p>
</details>
<hr />
<p>These functions are responsible for fetching the right information. Next,
let's look at the code for creating a new directory.</p>
<h3 id="createoutputdirectoryorexit"><a class="header" href="#createoutputdirectoryorexit"><code>createOutputDirectoryOrExit</code></a></h3>
<pre><code class="language-hs">-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create
</code></pre>
<p><code>createOutputDirectoryOrExit</code> itself is not terribly exciting; it does
what it is named -- it tries to create the output directory and exits the
program in case it didn't succeed.</p>
<p><code>createOutputDirectory</code> is the function that actually does the heavy lifting.
It checks if the directory already exists, and checks if the user would like to
override it. If they do, we remove it and create a new directory; if they don't,
we do nothing and report their decision.</p>
<h3 id="txtstorenderedhtml"><a class="header" href="#txtstorenderedhtml"><code>txtsToRenderedHtml</code></a></h3>
<pre><code class="language-hs">let
  outputHtmls = txtsToRenderedHtml filesToProcess
</code></pre>
<hr />
<p>In this part of the code, we convert files to markup and change the
input file paths to their respective output file paths (<code>.txt</code> -&gt; <code>.html</code>).
We then build the index page and convert everything to HTML.</p>
<p>Implement <code>txtsToRenderedHtml</code>, which has the following type signature:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
</code></pre>
<details><summary>Hint</summary>
<p>I implemented this by defining three functions:</p>
<pre><code class="language-hs">txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
</code></pre>
</details>
<p>.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)
</code></pre>
<p>One possibly surprising thing about this code could be the <code>map (fmap Html.render)</code>
part. We can use <code>fmap</code> on the tuple because it is a <code>Functor</code> on the second
argument, just like <code>Either</code>!</p>
</details>
<hr />
<h3 id="copyfiles-and-writefiles"><a class="header" href="#copyfiles-and-writefiles"><code>copyFiles</code> and <code>writeFiles</code></a></h3>
<p>The only thing left to do is to write the directory
content, after the processing is completed, to the newly created directory:</p>
<pre><code class="language-hs">-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Here we use <code>applyIoOnList</code> again to do something a bit more complicated,
instead of reading from a file, it copies from the input path to a newly generated
output path. Then we pass the result (which has the type <code>[(FilePath, Either String ())]</code>)
to <code>filterAndReportFailures</code> to print the errors and filter out the unsuccessful copies.
Because we are not really interested in the output of <code>filterAndReportFailures</code>,
we discard it with <code>void</code>, returning <code>()</code> as a result instead:</p>
<pre><code class="language-hs">-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures
</code></pre>
<p>Once again, this code looks almost exactly like <code>copyFiles</code>, but the types are different.
Haskell's combination of parametric polymorphism + type class for abstractions is really
powerful, and has helped us reduce quite a bit of code.</p>
<hr />
<p>This pattern of using <code>applyIoOnList</code> and then <code>filterAndReportFailures</code>
happens more than once. It might be a good candidate for refactoring. Try it!
What do you think about the resulting code? Is it easier or more difficult to
understand? Is it more modular or less? What are the pros and cons?</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>With that, we have completed our <code>HsBlog.Directory</code> module, which is responsible for converting
a directory safely. Note that the code could probably be simplified quite a bit if we
were fine with errors crashing the entire program altogether, but sometimes this is
the price we pay for robustness. It is up to you to choose what you can live with
and what not, but I hope this saga has taught you how to approach error handling
in Haskell in case you need to.</p>
<p>View the full module:</p>
<details><summary>HsBlog.Directory</summary>
<pre><code class="language-hs">-- | Process multiple files and convert directories

module HsBlog.Directory
  ( convertDirectory
  , buildIndex
  )
  where

import qualified HsBlog.Markup as Markup
import qualified HsBlog.Html as Html
import HsBlog.Convert (convert, convertStructure)

import Data.List (partition)
import Data.Traversable (for)
import Control.Monad (void, when)

import System.IO (hPutStrLn, stderr)
import Control.Exception (catch, displayException, SomeException(..))
import System.Exit (exitFailure)
import System.FilePath
  ( takeExtension
  , takeBaseName
  , (&lt;.&gt;)
  , (&lt;/&gt;)
  , takeFileName
  )
import System.Directory
  ( createDirectory
  , removeDirectoryRecursive
  , listDirectory
  , doesDirectoryExist
  , copyFile
  )

-- | Copy files from one directory to another, converting '.txt' files to
--   '.html' files in the process. Recording unsuccessful reads and writes to stderr.
--
-- May throw an exception on output directory creation.
convertDirectory :: FilePath -&gt; FilePath -&gt; IO ()
convertDirectory inputDir outputDir = do
  DirContents filesToProcess filesToCopy &lt;- getDirFilesAndContent inputDir
  createOutputDirectoryOrExit outputDir
  let
    outputHtmls = txtsToRenderedHtml filesToProcess
  copyFiles outputDir filesToCopy
  writeFiles outputDir outputHtmls
  putStrLn &quot;Done.&quot;

------------------------------------
-- * Read directory content

-- | Returns the directory content
getDirFilesAndContent :: FilePath -&gt; IO DirContents
getDirFilesAndContent inputDir = do
  files &lt;- map (inputDir &lt;/&gt;) &lt;$&gt; listDirectory inputDir
  let
    (txtFiles, otherFiles) =
      partition ((== &quot;.txt&quot;) . takeExtension) files
  txtFilesAndContent &lt;-
    applyIoOnList readFile txtFiles &gt;&gt;= filterAndReportFailures
  pure $ DirContents
    { dcFilesToProcess = txtFilesAndContent
    , dcFilesToCopy = otherFiles
    }

-- | The relevant directory content for our application
data DirContents
  = DirContents
    { dcFilesToProcess :: [(FilePath, String)]
      -- ^ File paths and their content
    , dcFilesToCopy :: [FilePath]
      -- ^ Other file paths, to be copied directly
    }

------------------------------------
-- * Build index page

buildIndex :: [(FilePath, Markup.Document)] -&gt; Html.Html
buildIndex files =
  let
    previews =
      map
        ( \(file, doc) -&gt;
          case doc of
            Markup.Heading 1 heading : article -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ heading))
                &lt;&gt; foldMap convertStructure (take 2 article)
                &lt;&gt; Html.p_ (Html.link_ file (Html.txt_ &quot;...&quot;))
            _ -&gt;
              Html.h_ 3 (Html.link_ file (Html.txt_ file))
        )
        files
  in
    Html.html_
      &quot;Blog&quot;
      ( Html.h_ 1 (Html.link_ &quot;index.html&quot; (Html.txt_ &quot;Blog&quot;))
        &lt;&gt; Html.h_ 2 (Html.txt_ &quot;Posts&quot;)
        &lt;&gt; mconcat previews
      )

------------------------------------
-- * Conversion

-- | Convert text files to Markup, build an index, and render as html.
txtsToRenderedHtml :: [(FilePath, String)] -&gt; [(FilePath, String)]
txtsToRenderedHtml txtFiles =
  let
    txtOutputFiles = map toOutputMarkupFile txtFiles
    index = (&quot;index.html&quot;, buildIndex txtOutputFiles)
  in
    map (fmap Html.render) (index : map convertFile txtOutputFiles)

toOutputMarkupFile :: (FilePath, String) -&gt; (FilePath, Markup.Document)
toOutputMarkupFile (file, content) =
  (takeBaseName file &lt;.&gt; &quot;html&quot;, Markup.parse content)

convertFile :: (FilePath, Markup.Document) -&gt; (FilePath, Html.Html)
convertFile (file, doc) = (file, convert file doc)

------------------------------------
-- * Output to directory

-- | Creates an output directory or terminates the program
createOutputDirectoryOrExit :: FilePath -&gt; IO ()
createOutputDirectoryOrExit outputDir =
  whenIO
    (not &lt;$&gt; createOutputDirectory outputDir)
    (hPutStrLn stderr &quot;Cancelled.&quot; *&gt; exitFailure)

-- | Creates the output directory.
--   Returns whether the directory was created or not.
createOutputDirectory :: FilePath -&gt; IO Bool
createOutputDirectory dir = do
  dirExists &lt;- doesDirectoryExist dir
  create &lt;-
    if dirExists
      then do
        override &lt;- confirm &quot;Output directory exists. Override?&quot;
        when override (removeDirectoryRecursive dir)
        pure override
      else
        pure True
  when create (createDirectory dir)
  pure create

-- | Copy files to a directory, recording errors to stderr.
copyFiles :: FilePath -&gt; [FilePath] -&gt; IO ()
copyFiles outputDir files = do
  let
    copyFromTo file = copyFile file (outputDir &lt;/&gt; takeFileName file)
  void $ applyIoOnList copyFromTo files &gt;&gt;= filterAndReportFailures

-- | Write files to a directory, recording errors to stderr.
writeFiles :: FilePath -&gt; [(FilePath, String)] -&gt; IO ()
writeFiles outputDir files = do
  let
    writeFileContent (file, content) =
      writeFile (outputDir &lt;/&gt; file) content
  void $ applyIoOnList writeFileContent files &gt;&gt;= filterAndReportFailures

------------------------------------
-- * IO work and handling errors

-- | Try to apply an IO function on a list of values, document successes and failures
applyIoOnList :: (a -&gt; IO b) -&gt; [a] -&gt; IO [(a, Either String b)]
applyIoOnList action inputs = do
  for inputs $ \input -&gt; do
    maybeResult &lt;-
      catch
        (Right &lt;$&gt; action input)
        ( \(SomeException e) -&gt; do
          pure $ Left (displayException e)
        )
    pure (input, maybeResult)

-- | Filter out unsuccessful operations on files and report errors to stderr.
filterAndReportFailures :: [(a, Either String b)] -&gt; IO [(a, b)]
filterAndReportFailures =
  foldMap $ \(file, contentOrErr) -&gt;
    case contentOrErr of
      Left err -&gt; do
        hPutStrLn stderr err
        pure []
      Right content -&gt;
        pure [(file, content)]

------------------------------------
-- * Utilities

confirm :: String -&gt; IO Bool
confirm question = do
  putStrLn (question &lt;&gt; &quot; (y/n)&quot;)
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. Use y or n.&quot;
      confirm question

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../06-errors_and_files/03-exceptions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../06-errors_and_files/05-summary.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../06-errors_and_files/03-exceptions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../06-errors_and_files/05-summary.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>
        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
