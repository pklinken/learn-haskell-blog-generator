<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Working with IO - Learn Haskell by building a blog generator</title>
        <!-- Custom HTML head -->
        <script defer data-domain="lhbg-book.link" src="https://analytics.gilmi.dev/js/plausible.js"></script>

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="Learn Haskell by building a blog generator">
        <meta name="twitter:description" content="A project-oriented online book about Haskell">
        <meta name="twitter:site" content="@_gilmi">
        <meta name="twitter:image" content="https://soupi.github.io/learn-haskell-blog-generator/book-logo.png">
        <meta name="twitter:image-alt" content="drawing of a lambda that is also a book">

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A project-oriented online book about Haskell">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../01-about.html"><strong aria-hidden="true">1.</strong> About this book</a></li><li class="chapter-item expanded "><a href="../02-hello.html"><strong aria-hidden="true">2.</strong> Hello world</a></li><li class="chapter-item expanded "><a href="../03-html_printer.html"><strong aria-hidden="true">3.</strong> Building an HTML printer library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-html/01-html_content.html"><strong aria-hidden="true">3.1.</strong> Flexible HTML content (functions)</a></li><li class="chapter-item expanded "><a href="../03-html/02-type_signatures.html"><strong aria-hidden="true">3.2.</strong> Adding type signatures</a></li><li class="chapter-item expanded "><a href="../03-html/03-edsls.html"><strong aria-hidden="true">3.3.</strong> Embedded Domain Specific Languages</a></li><li class="chapter-item expanded "><a href="../03-html/04-safer_construction.html"><strong aria-hidden="true">3.4.</strong> Safer HTML construction with types</a></li><li class="chapter-item expanded "><a href="../03-html/05-modules.html"><strong aria-hidden="true">3.5.</strong> Preventing incorrect use with modules</a></li><li class="chapter-item expanded "><a href="../03-html/06-escaping_characters.html"><strong aria-hidden="true">3.6.</strong> Escaping characters</a></li><li class="chapter-item expanded "><a href="../03-html/07-internal_modules.html"><strong aria-hidden="true">3.7.</strong> Exposing internal functionality (Internal modules)</a></li><li class="chapter-item expanded "><a href="../03-html/08-exercises.html"><strong aria-hidden="true">3.8.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../03-html/09-summary.html"><strong aria-hidden="true">3.9.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../04-markup.html"><strong aria-hidden="true">4.</strong> Custom markup language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-markup/01-data_type.html"><strong aria-hidden="true">4.1.</strong> Representing the markup language as a Haskell data type</a></li><li class="chapter-item expanded "><a href="../04-markup/02-parsing_01.html"><strong aria-hidden="true">4.2.</strong> Parsing markup part 01 (Recursion)</a></li><li class="chapter-item expanded "><a href="../04-markup/03-displaying_results.html"><strong aria-hidden="true">4.3.</strong> Displaying the parsing results (type classes)</a></li><li class="chapter-item expanded "><a href="../04-markup/04-parsing_02.html"><strong aria-hidden="true">4.4.</strong> Parsing markup part 02 (Pattern matching)</a></li></ol></li><li class="chapter-item expanded "><a href="../05-glue.html"><strong aria-hidden="true">5.</strong> Gluing things together</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../05-glue/01-markup_to_html.html"><strong aria-hidden="true">5.1.</strong> Converting Markup to HTML</a></li><li class="chapter-item expanded "><a href="../05-glue/02-io.html" class="active"><strong aria-hidden="true">5.2.</strong> Working with IO</a></li><li class="chapter-item expanded "><a href="../05-glue/03-project.html"><strong aria-hidden="true">5.3.</strong> Defining a project description</a></li><li class="chapter-item expanded "><a href="../05-glue/04-optparse.html"><strong aria-hidden="true">5.4.</strong> Fancy options parsing</a></li></ol></li><li class="chapter-item expanded "><a href="../06-errors_and_files.html"><strong aria-hidden="true">6.</strong> Handling errors and multiple files</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../06-errors_and_files/01-either.html"><strong aria-hidden="true">6.1.</strong> Handling errors with Either</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/02-except.html"><strong aria-hidden="true">6.2.</strong> Either with IO?</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/03-exceptions.html"><strong aria-hidden="true">6.3.</strong> Exceptions</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/04-implementation.html"><strong aria-hidden="true">6.4.</strong> Let's code already!</a></li><li class="chapter-item expanded "><a href="../06-errors_and_files/05-summary.html"><strong aria-hidden="true">6.5.</strong> Summary</a></li></ol></li><li class="chapter-item expanded "><a href="../07-environment.html"><strong aria-hidden="true">7.</strong> Passing an environment</a></li><li class="chapter-item expanded "><a href="../08-testing.html"><strong aria-hidden="true">8.</strong> Writing tests</a></li><li class="chapter-item expanded "><a href="../09-documentation.html"><strong aria-hidden="true">9.</strong> Generating documentation</a></li><li class="chapter-item expanded "><a href="../10-recap.html"><strong aria-hidden="true">10.</strong> Recap</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../11-next.html">Where to go next</a></li><li class="chapter-item expanded affix "><a href="../12-faq.html">Frequently asked questions</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Learn Haskell by building a blog generator</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/soupi/learn-haskell-blog-generator" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="working-with-io"><a class="header" href="#working-with-io">Working with IO</a></h1>
<p>In previous chapters, we were able to build a parser from a text
string to a Haskell representation of our markup language,
and we built an EDSL for easy writing of HTML code.
However, our program is still not useful to other users because
we did not make this functionality accessible via some sort of
user interface.</p>
<p>In our program, we'd like to take user input and then convert it to HTML.
There are many ways to design this kind of interface, for example:</p>
<ul>
<li>Get text input via the <em>standard input</em> and output HTML
via the <em>standard output</em></li>
<li>Receive two file names as <em>command-line arguments</em>, read the contents
of the first one, and write the output to the second one</li>
<li>Ask for fancier command-line arguments parsing and prefix
the file names with flags indicating what they are</li>
<li>Some fancy GUI interface</li>
<li>Combination of all of the above</li>
</ul>
<p>To make this interesting, we will start with the following interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name, and the second one
will be the output file name</li>
<li>If the output file already exists, we'll ask the user if they want
to overwrite the file</li>
<li>On any other kind of input, we'll print a generic message explaining
the proper usage</li>
</ol>
<p>In a later chapter, we will add a fancier command-line interface
using a library, and also read whole directories in addition to single files.</p>
<p>But first, we need to learn about I/O in Haskell, what makes
it special, and why it's different from other programming languages.</p>
<h2 id="purely-functional"><a class="header" href="#purely-functional">Purely functional</a></h2>
<p>Originally, Haskell was designed as an <em>open standard</em>
functional programming language with <strong>non-strict semantics</strong>, to serve
as a unifying language for future research in functional language design.</p>
<p>In GHC Haskell, we use a <em>lazy evaluation strategy</em> to implement non-strict
semantics (We've talked about laziness
<a href="../04-markup/02-parsing_01.html#laziness">before</a>).</p>
<p>The requirement for non-strict semantics raises interesting challenges:
How do we design a language that can do more than just evaluate expressions,
how do we model interaction with the outside world, how do we do I/O?</p>
<p>The challenge with doing I/O operations in a language with a lazy evaluation strategy
is that as programs grow larger, the order of evaluation becomes less trivial to
figure out. Consider this hypothetical code example
(which won't actually type-check in Haskell, we'll see why soon):</p>
<pre><code class="language-hs">addWithInput :: Int -&gt; Int
addWithInput n = readIntFromStdin + n

main =
  let
    result1 = addWithInput 1
    result2 = addWithInput 2
  in
    print (result2 - result1)
</code></pre>
<p>This hypothetical program will read 2 integers from the standard input,
and then will subtract the second one (+2) from the first one (+1),
or so we would expect if this was a strict language. In a strict language,
we expect the order of operations to happen from the top down.</p>
<p>But in a lazy language, we don't evaluate an expression until
it is needed, and so neither <code>result1</code> nor <code>result2</code> are evaluated
until we wish to print the result of subtracting one from the other.
And then, when we try to evaluate <code>-</code>, it evaluates the two arguments
from left to right, so we first evaluate <code>result2</code>.</p>
<p>Evaluating <code>result2</code> with substitution means replacing occurrences of <code>n</code>
with the input <code>2</code>, and then evaluate the top-level function (<code>+</code>), which is a
primitive function. We then evaluate its arguments, <code>readIntFromStdin</code>
and then <code>n</code>; at this point <em>we are reading the first integer from the stdin</em>.</p>
<p>After calculating the result, we can move to evaluate <code>result1</code>, which
<em>will read the second integer from stdin</em>. This is the
complete opposite of what we wanted!</p>
<p>Issues like these make lazy evaluation hard to work within the presence of
<strong>side effects</strong> - when the evaluation of an expression <em>can affect or be affected
by the outside world</em>, this includes reading/writing from mutable memory
or performing I/O operations.</p>
<p>We call functions that have side-effects, such as <code>addWithInput</code>, <strong>impure functions</strong>.
And an unfortunate consequence of impure functions is that
<strong>they can return different results even when they take the same input</strong>.</p>
<p>The presence of impure functions makes it harder for us to reason about lazy evaluation,
and also messes up our ability to use <strong>equational reasoning</strong> to understand programs.</p>
<p>Therefore, in Haskell, it was decided to only allow <strong>pure</strong> functions and expressions - ones that
have <strong>no side effects</strong>. Pure functions will <em>always</em> return the same output (given the same input)
and <strong>evaluating pure expressions is deterministic</strong>.</p>
<p>But now, how can we do I/O operations? There are many possible solutions.</p>
<p>For Haskell, it was decided to design an interface
with an accompanied type called <code>IO</code>. <code>IO</code>'s interface will force a distinction
from non-I/O expressions and will also require that in order to <em>combine</em>
multiple <code>IO</code> operations, we will have to <strong>specify the order of the operations</strong>.</p>
<h2 id="io"><a class="header" href="#io">IO</a></h2>
<p><code>IO</code> is an opaque type, like our <code>Html</code> type, in which we hide its internal
representation from the user behind an interface. But in this case, <code>IO</code> is a
built-in type and its internals are hidden by the Haskell language rather than a module.</p>
<p>Similar to <code>Maybe</code>, <code>IO</code> has a payload type that represents the
result of an <code>IO</code> operation.
When there isn't a meaningful result, we use the unit type,
<code>()</code> (which only has one value: <code>()</code>) to represent that.</p>
<p>Here are a few <code>IO</code> operations and functions that return <code>IO</code> operations:</p>
<pre><code class="language-hs">putStrLn :: String -&gt; IO ()

getLine :: IO String

getArgs :: IO [String]

lookupEnv :: String -&gt; IO (Maybe String)

writeFile :: FilePath -&gt; String -&gt; IO ()
</code></pre>
<!-- You can find more useful IO functions and operations in the
[System.IO](https://hackage.haskell.org/package/base-4.16.4.0/docs/System-IO.html) module,
which is shipped with `base`. -->
<p>Notice that each function returns an <code>IO &lt;something&gt;</code>, but what does that mean?</p>
<p>The meaning behind <code>IO a</code> is that it is a <em>description of a program (or subroutine)
that, when executed, will produce some value of type <code>a</code>, and may do some I/O effects
during execution</em>.</p>
<p>Executing an <code>IO a</code> is different from evaluating it.
Evaluating an <code>IO a</code> expression is pure - the <strong>evaluation</strong> will always reduce to
the same <strong>description</strong> of a program. This helps us keep purity and equational reasoning!</p>
<p>The Haskell runtime will <em>execute</em> the entry point to the program
(the expression <code>main</code> that must have the type <code>IO ()</code>). For our IO operation
to also run - it has to be <em>combined into</em> the <code>main</code> expression - let's see what that means.</p>
<h2 id="combining-io-expressions"><a class="header" href="#combining-io-expressions">Combining IO expressions</a></h2>
<p>Like our <code>Html.Structure</code> type, the IO interface provides <strong>combinators</strong> for composing
small <code>IO</code> operations into bigger ones. This interface also ensures that the order
of operations is well-defined!</p>
<p>Note that, just like the <code>&lt;&gt;</code> we've defined for <code>Html.Structure</code>, the combinators for <code>IO</code>
are implemented as <strong>type-class instances</strong> rather than specialized variants
(for example our <code>append_</code> function was a specialized version of <code>&lt;&gt;</code> tailored only
for <code>Structure</code>).</p>
<p>In this section, I will introduce specialized type signatures rather than generalized ones,
because I think it'll be easier to digest, but we'll talk about the generalized versions
later.</p>
<h3 id=""><a class="header" href="#">&gt;&gt;=</a></h3>
<p>Our first combinator is <code>&gt;&gt;=</code> (pronounced bind), and is the most useful of the bunch:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>This combinator takes two arguments, the first is an IO operation, and the second is
a function that takes as input <em>the result of the first IO operation</em> and returns
a new <code>IO b</code>, which is the final result.</p>
<p>Here are a few examples using the functions we described above:</p>
<ol>
<li>
<p>Echo</p>
<pre><code>getLine &gt;&gt;= (\line -&gt; putStrLn line)
</code></pre>
<p>We are reading a line from the standard input on the left of <code>&gt;&gt;=</code>,
we receive the input to the right of <code>&gt;&gt;=</code> as an argument to the lambda function,
and then write it to the standard output in the body of the lambda function.
<code>&gt;&gt;=</code>'s role here is to <strong>pass the result of the IO operation
on the left to the function returning an IO operation on the right</strong>.</p>
<p>Notice how <code>&gt;&gt;=</code> <em>defines an order of operations - from left to right</em>.</p>
<p>The type of each sub-expression here is:</p>
<pre><code class="language-hs">getLine :: IO String

putStrLn :: String -&gt; IO ()

(&gt;&gt;=) :: IO String -&gt; (String -&gt; IO ()) -&gt; IO ()

line :: String
</code></pre>
<ul>
<li>Question: what is the type of the whole expression? <details><summary>Answer</summary>IO ()</details></li>
</ul>
<p>Also, note that this example can be written in a more concise manner
in point-free style <code>getLine &gt;&gt;= putStrLn</code>.</p>
</li>
<li>
<p>Appending two inputs</p>
<pre><code>getLine &gt;&gt;= (\honorific -&gt; getLine &gt;&gt;= (\name -&gt; putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)))
</code></pre>
<p>This subroutine combines multiple operations together; it reads two lines from
the standard input and prints a greeting.
Note that:</p>
<ul>
<li>Using <code>&gt;&gt;=</code> defines the order of operation from left to right</li>
<li>Because of the scoping rules in Haskell, <code>honorific</code> will be in scope
in the body of the function for which it is its input, including the most inner function</li>
</ul>
<p>This is a bit hard to read, but we can remove the parenthesis and add indentation to make it a bit easier to read:</p>
<pre><code>getLine &gt;&gt;= \honorific -&gt;
  getLine &gt;&gt;= \name -&gt;
    putStrLn (&quot;Hello &quot; ++ honorific ++ &quot; &quot; ++ name)
</code></pre>
</li>
</ol>
<p>Let's see a few more combinators!</p>
<h3 id="-and"><a class="header" href="#-and">*&gt; and &gt;&gt;</a></h3>
<pre><code class="language-hs">(*&gt;) :: IO a -&gt; IO b -&gt; IO b
(&gt;&gt;) :: IO a -&gt; IO b -&gt; IO b
</code></pre>
<p><code>*&gt;</code> and <code>&gt;&gt;</code> have the same type signature for <code>IO</code> and mean the same thing.
In fact, <code>*&gt;</code> is a slightly more generalized version of <code>&gt;&gt;</code> and can always
be used instead of <code>&gt;&gt;</code>, which only still exists to avoid breaking backward
compatibility.</p>
<p><code>*&gt;</code> for <code>IO</code> means run the first IO operation, discard the result
then run the second operation. It can be implemented using <code>&gt;&gt;=</code>:</p>
<pre><code>a *&gt; b = a &gt;&gt;= \_ -&gt; b
</code></pre>
<p>This combinator is useful when we want to run several <code>IO</code> operations one after
the other that might not return anything meaningful, such as <code>putStrLn</code>:</p>
<pre><code>putStrLn &quot;hello&quot; *&gt; putStrLn &quot;world&quot;
</code></pre>
<h3 id="pure-and-return"><a class="header" href="#pure-and-return">pure and return</a></h3>
<pre><code class="language-hs">pure :: a -&gt; IO a
</code></pre>
<p>like <code>*&gt;</code> and <code>&gt;&gt;</code>, <code>pure</code> is a more general version of <code>return</code>. <code>pure</code> also has the
advantage of not having a resemblance to an unrelated keyword in other languages.</p>
<p>Remember that we said <code>IO a</code> is a description of a program
that, when executed, will produce some value of type <code>a</code> and may do some I/O effects
during execution?</p>
<p>With <code>pure</code>, we can build an <code>IO a</code> that does no I/O and will produce a
specific value of type <code>a</code>, the one we supply to <code>pure</code>!</p>
<p>This function is useful when we want to do some uneffectful computation that depends on <code>IO</code>.</p>
<p>For example:</p>
<pre><code class="language-hs">confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt;
          putStrLn &quot;Invalid response. use y or n&quot; *&gt;
            confirm
</code></pre>
<p>Trying to return just <code>True</code> or <code>False</code> here wouldn't work because of the
type of <code>&gt;&gt;=</code>:</p>
<pre><code class="language-hs">(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b
</code></pre>
<p>The right side of <code>&gt;&gt;=</code> in our code example (<code>\answer -&gt; case ...</code>) must
be of type <code>String -&gt; IO Bool</code>. This is because:</p>
<ol>
<li><code>getLine :: IO String</code>, so the <code>a</code> in the type signature of <code>&gt;&gt;=</code>
should be the same as <code>String</code> in this instance, and</li>
<li><code>confirm :: IO Bool</code>, so <code>b</code> should be <code>Bool</code></li>
</ol>
<h3 id="fmap-and-"><a class="header" href="#fmap-and-">fmap and &lt;$&gt;</a></h3>
<pre><code class="language-hs">fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<p><code>&lt;$&gt;</code> is the infix version of <code>fmap</code>. Use it at your discretion.</p>
<p>What if we want a function that reads a line from stdin
and returns it with <code>!</code> at the end? We could use a combination
of <code>&gt;&gt;=</code> and <code>pure</code>:</p>
<pre><code>getLine &gt;&gt;= \line -&gt; pure (line ++ &quot;!&quot;)
</code></pre>
<p>The pattern is unified to the <code>fmap</code> function:</p>
<pre><code>fmap (\line -&gt; line ++ &quot;!&quot;) getLine
</code></pre>
<p><code>fmap</code> applies a function to the value to be returned
from the <code>IO</code> operation, also known as &quot;mapping&quot; over it.</p>
<p>(By the way, Have you noticed the similarities between <code>fmap</code> and <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>?)</p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>Here's a list of <code>IO</code> combinators we ran into:</p>
<pre><code class="language-hs">-- chaining IO operations: passing the *result* of the left IO operation
-- as an argument to the function on the right.
-- Pronounced &quot;bind&quot;.
(&gt;&gt;=) :: IO a -&gt; (a -&gt; IO b) -&gt; IO b

-- sequence two IO operations, discarding the payload of the first.
(*&gt;) :: IO a -&gt; IO b -&gt; IO b

-- &quot;lift&quot; a value into IO context, does not add any I/O effects.
pure :: a -&gt; IO a

-- &quot;map&quot; (or apply a function) over the payload value of an IO operation.
fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b
</code></pre>
<h2 id="io-is-first-class"><a class="header" href="#io-is-first-class">IO is first class</a></h2>
<p>The beauty of <code>IO</code> is that it's a completely first-class construct in the language,
and is not really different from <code>Maybe</code>, <code>Either</code>, or <code>Structure</code>. We can pass it to
functions, put it in a container, etc. Remember that it represents a description
of a program, and without combining it into <code>main</code> in some way won't actually
<em>do</em> anything. It is just a value!</p>
<p>Here's an example of a function that takes IO actions as input:</p>
<pre><code class="language-hs">whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
<p>And how it can be used:</p>
<pre><code class="language-hs">main :: IO ()
main =
  putStrLn &quot;This program will tell you a secret&quot; *&gt;
    whenIO confirm (putStrLn &quot;IO is actually pretty awesome&quot;) *&gt;
      putStrLn &quot;Bye&quot;
</code></pre>
<p>Notice how <code>putStrLn &quot;IO is actually pretty awesome&quot;</code> isn't executed
right away, but only if it is what <code>whenIO</code> returns, and in turn, is <em>combined</em>
with <code>*&gt;</code> as part of the <code>main</code> expression.</p>
<h2 id="getting-out-of-io"><a class="header" href="#getting-out-of-io">Getting out of IO?</a></h2>
<p>What we've seen above has great consequences for the Haskell language.
In our <code>Html</code> type, we had a function <code>render :: Html -&gt; String</code>
that could turn an <code>Html</code> into a string value.</p>
<p>In Haskell, <strong>there is no way</strong> to implement a function such as <code>execute :: IO a -&gt; a</code>
that preserves purity and equational reasoning!</p>
<p>Also, <code>IO</code> is <em>opaque</em>. It does not let us examine it. So we are really bound
to what the Haskell API for <code>IO</code> allows us to do.</p>
<p>This means that <strong>we need to think about using IO differently</strong>!</p>
<p>In Haskell, once we get into <code>IO</code>, there is no getting out.
The only thing we can do is to build bigger IO computations by <em>combining</em>
it with more IO computations.</p>
<p>We also can't use <code>IO a</code> in place of an <code>a</code>. For example,
we can't write <code>getLine ++ &quot;!&quot;</code> because <code>++</code> expects both
sides to be <code>String</code>, but <code>getLine</code>'s type is <code>IO String</code>. The types do not match!
We have to use <code>fmap</code>, and the return type must be <code>IO String</code>, as we've seen before.</p>
<p>In Haskell, we like to keep <code>IO</code> usage minimal, and we like to push it to the edges
of the program. This pattern is often called <em>Functional core, imperative shell</em>.</p>
<h2 id="functional-core-imperative-shell"><a class="header" href="#functional-core-imperative-shell">Functional core, imperative shell</a></h2>
<p>In our blog generator program, we want to read a file, parse it, convert it to HTML,
and then print the result to the console.</p>
<p>In many programming languages, we might interleave reading from the file with parsing,
and writing to the file with the HTML conversion. But we don't mix these here.
Parsing operates on a <code>String</code> value rather than some file handle,
and <code>Html</code> is being converted to a <code>String</code> rather than being written to the screen directly.</p>
<p>This approach of separating <code>IO</code> and pushing it to the edge of the program gives us
a lot of flexibility. These functions without <code>IO</code> are easier to test and examine
(because they are guaranteed to have deterministic evaluation!),
and they are more modular and can work in many contexts (reading from stdin,
reading from a network socket, writing to an HTTP connection, and more).</p>
<p>This pattern is often a good approach for building Haskell programs, especially
batch programs.</p>
<h2 id="building-a-blog-generator"><a class="header" href="#building-a-blog-generator">Building a blog generator</a></h2>
<p>We'd like to start building a blog generator, and we want to have the following
interface:</p>
<ol>
<li>If the user calls the program without arguments, we will read from
the standard input, and write to the standard output</li>
<li>If the user calls the program with two arguments, the first one
will be the input file name, and the second one
will be the output file name</li>
<li>If the output file already exists, we'll ask the user if they want
to overwrite the file</li>
<li>On any other kind of input, we'll print a generic message explaining
the proper usage</li>
</ol>
<p>We are going to need a few functions:</p>
<pre><code class="language-hs">getArgs :: IO [String] -- Get the program arguments

getContents :: IO String -- Read all of the content from stdin

readFile :: FilePath -&gt; IO String -- Read all of the content from a file

writeFile :: FilePath -&gt; String -&gt; IO () -- Write a string into a file

doesFileExist :: FilePath -&gt; IO Bool -- Checks whether a file exists
</code></pre>
<p>And the following imports:</p>
<pre><code class="language-hs">import System.Directory (doesFileExist)
import System.Environment (getArgs)
</code></pre>
<p>We don't need to add the following import because <code>Prelude</code> already imports
these functions for us:</p>
<pre><code class="language-hs">-- imported by Prelude
import System.IO (getContents, readFile, writeFile)
</code></pre>
<hr />
<ol>
<li>
<p>Implement a function <code>process :: Title -&gt; String -&gt; String</code> which will parse
a document to markup, convert it to HTML, and then render the HTML to a string.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse
</code></pre>
</details>
</li>
<li>
<p>Try implementing the &quot;imperative shell&quot; for our blog generator program.
Start with <code>main</code>, pattern match on the result of <code>getArgs</code>, and decide what to
do. Look back at the examples above for inspiration.</p>
<details><summary>Answer</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main =
  getArgs &gt;&gt;= \args -&gt;
    case args of
      -- No program arguments: reading from stdin and writing to stdout
      [] -&gt;
        getContents &gt;&gt;= \content -&gt;
          putStrLn (process &quot;Empty title&quot; content)

      -- With input and output file paths as program arguments
      [input, output] -&gt;
        readFile input &gt;&gt;= \content -&gt;
          doesFileExist output &gt;&gt;= \exists -&gt;
            let
              writeResult = writeFile output (process input content)
            in
              if exists
                then whenIO confirm writeResult
                else writeResult

      -- Any other kind of program arguments
      _ -&gt;
        putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm =
  putStrLn &quot;Are you sure? (y/n)&quot; *&gt;
    getLine &gt;&gt;= \answer -&gt;
      case answer of
        &quot;y&quot; -&gt; pure True
        &quot;n&quot; -&gt; pure False
        _ -&gt; putStrLn &quot;Invalid response. use y or n&quot; *&gt;
          confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action =
  cond &gt;&gt;= \result -&gt;
    if result
      then action
      else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="do-notation"><a class="header" href="#do-notation">Do notation</a></h2>
<p>While using <code>&gt;&gt;=</code> to chain <code>IO</code> actions is manageable, Haskell provides
an even more convenient syntactic sugar called <em>do notation</em>
which emulates imperative programming.</p>
<p>A <em>do block</em> starts with the <code>do</code> keyword and continues with one or more
&quot;statements&quot; which can be one of the following:</p>
<ol>
<li>An expression of type <code>IO ()</code>, such as:
<ul>
<li><code>putStrLn &quot;Hello&quot;</code></li>
<li><code>if True then putStrLn &quot;Yes&quot; else putStrLn &quot;No&quot;</code></li>
</ul>
</li>
<li>A let block, such as
<ul>
<li><code>let x = 1</code></li>
<li>or multiple let declarations:
<pre><code class="language-hs">let
  x = 1
  y = 2
</code></pre>
Note that we do not write the <code>in</code> here.</li>
</ul>
</li>
<li>A binding <code>&lt;variable&gt; &lt;- &lt;expresion&gt;</code>, such as
<pre><code class="language-hs">line &lt;- getLine
</code></pre>
</li>
</ol>
<p>And the last &quot;statement&quot; must be an expression of type <code>IO &lt;something&gt;</code> -
this will be the result type of the do block.</p>
<p>These constructs are desugared (translated) by the Haskell compiler to:</p>
<ol>
<li><code>&lt;expression&gt; *&gt;</code>,</li>
<li><code>let ... in</code> and</li>
<li><code>&lt;expression&gt; &gt;&gt;= \&lt;variable&gt;</code></li>
</ol>
<p>respectively.</p>
<p>For example:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting = do
  putStrLn &quot;Tell me your name.&quot;
  let greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
  name &lt;- getLine
  putStrLn (greet name)
</code></pre>
<p>Is just syntactic sugar for:</p>
<pre><code class="language-hs">greeting :: IO ()
greeting =
  putStrLn &quot;Tell me your name.&quot; *&gt;
    let
      greet name = &quot;Hello, &quot; ++ name ++ &quot;!&quot;
    in
      getLine &gt;&gt;= \name -&gt;
        putStrLn (greet name)
</code></pre>
<p>It's important to note the difference between <code>let</code> and <code>&lt;-</code> (bind).
<code>let</code> is used to give a new name to an expression that will be in scope
for subsequent lines, and <code>&lt;-</code> is used to bind the result <code>a</code> in an <code>IO a</code>
action to a new name that will be in scope for subsequent lines.</p>
<table>
  <tr>
    <th>code</th>
    <th>operator</th>
    <th>type of the left side</th>
    <th>type of the right side</th>
    <th>comment</th>
  </tr>
  <tr>
    <td><pre><pre>let greeting = "hello"</pre></pre></td>
    <td><pre>=</pre></td>
    <td><pre>String</pre></td>
    <td><pre>String</pre></td>
    <td>Both sides are interchangeable</td>
  </tr>
  <tr>
    <td><pre>let mygetline = getLine</pre></td>
    <td><pre>=</pre></td>
    <td><pre>IO String</pre></td>
    <td><pre>IO String</pre></td>
    <td>We just create a new name for <code>getLine</code></td>
  </tr>
  <tr>
    <td><pre>name <- getLine</pre></td>
    <td><pre><-</pre></td>
    <td><pre>String</pre></td>
    <td><pre>IO String</pre></td>
    <td>Technically <code><-</code> is not an operator, but just a syntactic sugar for <code>>>=</code> + lambda, where we bind the result of the computation to a variable</td>
  </tr>
</table>
<p>Do notation is very very common and is often preferable to using <code>&gt;&gt;=</code> directly.</p>
<hr />
<ol>
<li>
<p>Exercise: Translate the examples in this chapter to <em>do notation</em>.</p>
</li>
<li>
<p>Exercise: Translate our glue code for the blog generator to <em>do notation</em>.</p>
<details><summary>Solution</summary>
<pre><code class="language-hs">-- Main.hs
module Main where

import qualified Markup
import qualified Html
import Convert (convert)

import System.Directory (doesFileExist)
import System.Environment (getArgs)

main :: IO ()
main = do
  args &lt;- getArgs
  case args of
    -- No program arguments: reading from stdin and writing to stdout
    [] -&gt; do
      content &lt;- getContents
      putStrLn (process &quot;Empty title&quot; content)

    -- With input and output file paths as program arguments
    [input, output] -&gt; do
      content &lt;- readFile input
      exists &lt;- doesFileExist output
      let
        writeResult = writeFile output (process input content)
      if exists
        then whenIO confirm writeResult
        else writeResult

    -- Any other kind of program arguments
    _ -&gt;
      putStrLn &quot;Usage: runghc Main.hs [-- &lt;input-file&gt; &lt;output-file&gt;]&quot;

process :: Html.Title -&gt; String -&gt; String
process title = Html.render . convert title . Markup.parse

confirm :: IO Bool
confirm = do
  putStrLn &quot;Are you sure? (y/n)&quot;
  answer &lt;- getLine
  case answer of
    &quot;y&quot; -&gt; pure True
    &quot;n&quot; -&gt; pure False
    _ -&gt; do
      putStrLn &quot;Invalid response. use y or n&quot;
      confirm

whenIO :: IO Bool -&gt; IO () -&gt; IO ()
whenIO cond action = do
  result &lt;- cond
  if result
    then action
    else pure ()
</code></pre>
</details>
</li>
</ol>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In this chapter, we discussed what &quot;purely functional&quot; means,
where the initial motivation for being purely functional comes from,
and how Haskell's I/O interface allows us to create descriptions of programs
without breaking purity.</p>
<p>We have also achieved a major milestone. With this chapter, we have implemented
enough pieces to finally run our program on a single document
and get an HTML-rendered result!</p>
<p>However, our command-line interface is still sub-par. We want to render a blog
with multiple articles, create an index page, and more. We still have more to do
to be able to call our program a blog generator.</p>
<p>Let's keep going!</p>
<blockquote>
<p>You can view the git commit of
<a href="https://github.com/soupi/learn-haskell-blog-generator/commit/908e7173cf32de5ce8507e43a1fb9124fc5d63f4">the changes we've made</a>
and the <a href="https://github.com/soupi/learn-haskell-blog-generator/tree/908e7173cf32de5ce8507e43a1fb9124fc5d63f4">code up until now</a>.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../05-glue/01-markup_to_html.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../05-glue/03-project.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../05-glue/01-markup_to_html.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../05-glue/03-project.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script>
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" charset="utf-8"></script>
        <script src="../mark.min.js" charset="utf-8"></script>
        <script src="../searcher.js" charset="utf-8"></script>
        <script src="../clipboard.min.js" charset="utf-8"></script>
        <script src="../highlight.js" charset="utf-8"></script>
        <script src="../book.js" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
